REPORT GENERATED FOR USER: tinhn

==================== SCANNING: /home/tinhn/repo/AIRuningCoach ====================
--- STRUCTURE: AIRuningCoach ---
AIRuningCoach/
    setup_strava.py
    .gitignore
    config.example.json
    Dockerfile
    README.md
    check_model.p
    app.log
    .env
    requirements.txt
    main.py
    arch.txt
    templates/
        admin.html
    docs/
        setup.md
        architecture.md
        changelog.md
        flows.md
    tools/
        __init__.py
        strava_client.py
        strava_tools.py
        notify_tools.py
    agents/
        __init__.py
        coach_agent.py

--- CONTENTS: AIRuningCoach ---

>>> START FILE: ~/repo/AIRuningCoach/setup_strava.py
import requests
import webbrowser

# --- C·∫§U H√åNH T·∫†M TH·ªúI ƒê·ªÇ L·∫§Y TOKEN ---
# B·∫°n h√£y ƒëi·ªÅn Client ID v√† Secret t·ª´ Strava v√†o ƒë√¢y ƒë·ªÉ ch·∫°y script n√†y
CLIENT_ID = '200332' 
CLIENT_SECRET = '24b7ad5bbcd7abadf02ecad1e11a048da15536ed'

def get_tokens():
    # B∆∞·ªõc 1: T·∫°o link login
    url = f"https://www.strava.com/oauth/authorize?client_id={CLIENT_ID}&response_type=code&redirect_uri=http://localhost&approval_prompt=force&scope=activity:read_all,activity:write"
    
    print("1. H√£y m·ªü link sau tr√™n tr√¨nh duy·ªát v√† b·∫•m 'Authorize':")
    print(url)
    
    # B∆∞·ªõc 2: Nh·∫≠p code
    print("\n2. Sau khi authorize, tr√¨nh duy·ªát s·∫Ω b√°o l·ªói (localhost).")
    print("Nh√¨n tr√™n thanh ƒë·ªãa ch·ªâ, copy ƒëo·∫°n m√£ sau d·∫•u '?code='")
    code = input("D√°n code v√†o ƒë√¢y: ")
    
    # B∆∞·ªõc 3: ƒê·ªïi code l·∫•y token
    payload = {
        'client_id': CLIENT_ID,
        'client_secret': CLIENT_SECRET,
        'code': code,
        'grant_type': 'authorization_code'
    }
    
    try:
        res = requests.post("https://www.strava.com/oauth/token", data=payload)
        res.raise_for_status()
        data = res.json()
        
        print("-" * 60)
        print("TH√ÄNH C√îNG! H√ÉY COPY D√íNG D∆Ø·ªöI V√ÄO FILE .env C·ª¶A B·∫†N:")
        print(f"STRAVA_REFRESH_TOKEN={data['refresh_token']}")
        print("-" * 60)
    except Exception as e:
        print(f"L·ªói: {e}")

if __name__ == "__main__":
    get_tokens()
<<< END FILE: ~/repo/AIRuningCoach/setup_strava.py

>>> START FILE: ~/repo/AIRuningCoach/config.example.json
{
    "system_instruction": "B·∫°n l√† m·ªôt hu·∫•n luy·ªán vi√™n ch·∫°y b·ªô chuy√™n nghi·ªáp, am hi·ªÉu sinh l√Ω h·ªçc th·ªÉ thao",
    "user_profile": "User l√† nam, ƒëang train sub 1:45 HM. Ng√†y race 29.03.2026, HR Max 185, s·ªü h·ªØu Garmin 955",
    "task_description": "H√£y ph√¢n t√≠ch chi ti·∫øt b√†i t·∫≠p n√†y. ƒë·ªçc to√†n b·ªô c·∫•u tr√∫c b√†i ch·∫°y, h√£y k·∫øt h·ª£p power, run dynamic, cadence, stride, v√† nhip tim, pace, Performance Condition, Body Battery,  Stamina V√† k·∫øt h·ª£p l·ªãch s·ª≠ tr√≤ chuy·ªán profile. T·ª´ ƒë√≥ ƒë∆∞a ra nh·∫≠n ƒë·ªãnh. ƒê√°nh gi√° chi ti√™t. v√† l·∫≠p b√°o c√°o.  v√† ph√¢n t√≠ch d·ªØ li·ªáu v√† profile ƒë√£ trao ƒë·ªïi, H√£y ph√¢n t√≠ch b√†i ch·∫°y n√†y nh∆∞ m·ªôt hu·∫•n luy·ªán vi√™n nghi√™m kh·∫Øc nh∆∞ng kh√≠ch l·ªá...",
    "analysis_requirements": "1. Effort Analysis: Based on HR Max and Resting HR, determine the primary Heart Rate Zones used.\n2. Pacing Strategy: Analyze 'Velocity_m_s'. Did the runner maintain a steady pace? Look for positive/negative splits.\n3. Technique & Terrain: Correlation between 'Cadence_spm' and 'Grade_pct'.\n4. Verdict: Give a short, actionable summary for the next session.",
    "output_format": "- Do NOT use Markdown (no **bold**, no ## headers, no tables).\n- Use UPPERCASE for section headers.\n- Use Emojis for visual bullet points.\n- Structure exactly like this:\n\nüî• PH√ÇN T√çCH NH·ªäP TIM\n(Short analysis of effort/zones)\n\n‚ö° CHI·∫æN THU·∫¨T PACE\n(Comments on pacing consistency)\n\nü¶∂ K·ª∏ THU·∫¨T & ƒê·ªäA H√åNH\n(Cadence and terrain analysis)\n\nüéØ K·∫æT LU·∫¨N\n(Final verdict and actionable advice for next run)\n\n---\nü§ñ AI Coach",
    "email_config": {
      "enabled": true,
      "smtp_server": "smtp.gmail.com",
      "smtp_port": 587,
      "sender_email": "Sender@gmail.com",
      "sender_password": "your sender email app password",
      "receiver_email": "your reciever email@gmail.com"
    },
    "admin_auth": {
      "username": "admin",
      "password": "123"
    }
  }
<<< END FILE: ~/repo/AIRuningCoach/config.example.json

>>> START FILE: ~/repo/AIRuningCoach/Dockerfile
# D√πng Python nh·∫π
FROM python:3.11-slim

# Thi·∫øt l·∫≠p th∆∞ m·ª•c l√†m vi·ªác
WORKDIR /app

# Copy file th∆∞ vi·ªán v√† c√†i ƒë·∫∑t
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy to√†n b·ªô code v√†o
COPY . .

# M·ªü c·ªïng 8000
EXPOSE 8000

# L·ªánh ch·∫°y App khi kh·ªüi ƒë·ªông
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

<<< END FILE: ~/repo/AIRuningCoach/Dockerfile

>>> START FILE: ~/repo/AIRuningCoach/README.md
---

# üèÉ‚Äç‚ôÇÔ∏è AI Running Coach (Coach Dyno)

**Project Owner:** TinhN (T440 Home Lab)

**Goal:** X√¢y d·ª±ng m·ªôt AI Agent c√° nh√¢n h√≥a, t·ª± ƒë·ªông ph√¢n t√≠ch d·ªØ li·ªáu ch·∫°y b·ªô t·ª´ Strava, ƒë∆∞a ra l·ªùi khuy√™n chi·∫øn thu·∫≠t v√† hu·∫•n luy·ªán d·ª±a tr√™n m·ª•c ti√™u Half Marathon Sub 1:45 (2026).

---

## üèóÔ∏è 1. System Architecture (Ki·∫øn tr√∫c H·ªá th·ªëng)

H·ªá th·ªëng ho·∫°t ƒë·ªông tr√™n m√¥ h√¨nh **Event-Driven Microservices** ch·∫°y trong Docker container, ƒë∆∞·ª£c host t·∫°i gia (Home Lab).

### üìê High-Level Data Flow

```mermaid
graph TD
    User(Runner) -->|Upload Run| Strava[Strava Cloud]
    Strava -->|Webhook POST| DuckDNS[DuckDNS Domain]
    DuckDNS -->|Port 443| Nginx[Nginx Proxy Manager]
    Nginx -->|Reverse Proxy| FastAPI[AI Coach Container]
    
    subgraph "AI Coach Container (Python/FastAPI)"
        FastAPI -->|Trigger| Workflow[Main Workflow]
        Workflow -->|Fetch Data| StravaClient[Strava Tools]
        Workflow -->|Generate Prompt| Agent[Coach Agent]
        Agent -->|API Call| Gemini[Google Gemini API]
        Gemini -->|Analysis Text| Agent
        Agent -->|Update Description| StravaClient
        Agent -->|Notify| Telegram[Telegram Bot Tools]
    end
    
    User -->|Chat/Query| Telegram
    Telegram -->|Webhook| FastAPI

```

### üìÇ Project Structure (Modular Design)

```bash
AIRunningCoach/
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ coach_agent.py    # Logic AI, t·∫°o Prompt, g·ªçi Gemini (Multi-model support)
‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ strava_client.py  # X·ª≠ l√Ω Strava API (Fetch CSV, Update Activity)
‚îÇ   ‚îî‚îÄ‚îÄ notify_tools.py   # G·ª≠i tin nh·∫Øn Telegram/Email (T√°ch bi·ªát ƒë·ªÉ t√°i s·ª≠ d·ª•ng)
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ admin.html        # Giao di·ªán Web Admin (Config, Logs, Model Select)
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ config.json       # L∆∞u c·∫•u h√¨nh ƒë·ªông (System Instruction, Model Name)
‚îú‚îÄ‚îÄ main.py               # API Gateway (FastAPI), Webhook Handler
‚îú‚îÄ‚îÄ Dockerfile            # M√¥i tr∆∞·ªùng ch·∫°y (Python 3.11-slim)
‚îî‚îÄ‚îÄ requirements.txt      # Dependencies (FastAPI, Google-GenAI, Pandas...)

```

---

## üõ†Ô∏è 2. Recent Bug Fixes (Nh·∫≠t k√Ω S·ª≠a l·ªói)

Danh s√°ch c√°c l·ªói quan tr·ªçng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong giai ƒëo·∫°n ph√°t tri·ªÉn (Dev Phase 1):

* **[CRITICAL] Kh·∫Øc ph·ª•c l·ªói Quota 429 (Google Gemini API):**
* *V·∫•n ƒë·ªÅ:* Model `gemini-flash-latest` (Gemini 3.0 Preview) c√≥ gi·ªõi h·∫°n 20 request/ng√†y, g√¢y crash h·ªá th·ªëng khi test nhi·ªÅu.
* *Gi·∫£i ph√°p:* Th√™m t√≠nh nƒÉng **Live Model Switch** tr√™n Web Admin. Cho ph√©p chuy·ªÉn ƒë·ªïi n√≥ng gi·ªØa `Gemini 2.0 Flash`, `Gemini 2.5 Flash` (Smart) v√† `Gemini 1.5 Flash` (Stable/Backup) m√† kh√¥ng c·∫ßn restart Docker.


* **[FIX] L·ªói `NameError` trong Telegram Handler:**
* *V·∫•n ƒë·ªÅ:* T√°ch h√†m `send_telegram_msg` sang file `tools/notify_tools.py` nh∆∞ng qu√™n import v√†o `agents/coach_agent.py`, d·∫´n ƒë·∫øn bot kh√¥ng th·ªÉ ph·∫£n h·ªìi.
* *Gi·∫£i ph√°p:* Th·ª±c hi·ªán import ƒë√∫ng chu·∫©n module: `from tools.notify_tools import send_telegram_msg`.


* **[FIX] Syntax Error trong Exception Handling:**
* *V·∫•n ƒë·ªÅ:* L·ªói copy-paste l√†m d√≠nh d√≤ng l·ªánh `send_telegram_msg` v√†o `logger.error`, g√¢y s·∫≠p container khi c√≥ l·ªói ngo·∫°i l·ªá.
* *Gi·∫£i ph√°p:* Clean code v√† chu·∫©n h√≥a block `try...except`.


* **[FEATURE] Deep Debug Mode:**
* *V·∫•n ƒë·ªÅ:* C·∫ßn xem Prompt g·ª≠i ƒëi ƒë·ªÉ t·ªëi ∆∞u nh∆∞ng kh√¥ng mu·ªën log to√†n b·ªô raw CSV (g√¢y r√°c log).
* *Gi·∫£i ph√°p:* Th√™m ch·∫ø ƒë·ªô Debug ·∫©n CSV (`[...RAW DATA HIDDEN...]`) nh∆∞ng v·∫´n hi·ªán ƒë·∫ßy ƒë·ªß System Instruction v√† User Context.



---

## üìù 3. Roadmap & Todo List

D·ª±a tr√™n Project Charter ban ƒë·∫ßu, d∆∞·ªõi ƒë√¢y l√† l·ªô tr√¨nh ti·∫øp theo:

### üöÄ Phase 1: Core Automation (‚úÖ DONE)

* [x] Thi·∫øt l·∫≠p Docker & Nginx Proxy Manager.
* [x] K·∫øt n·ªëi Strava Webhook (Nh·∫≠n d·ªØ li·ªáu Run).
* [x] T√≠ch h·ª£p Gemini API (Ph√¢n t√≠ch d·ªØ li·ªáu CSV).
* [x] C·∫≠p nh·∫≠t l·∫°i Description tr√™n Strava t·ª± ƒë·ªông.
* [x] Web Admin Dashboard (Ch·ªânh s·ª≠a Prompt, xem Log).
* [x] G·ª≠i th√¥ng b√°o qua Telegram.

### üß† Phase 2: Intelligence & Memory (üöß IN PROGRESS)

* [ ] **Contextual Chat (Tr√≠ nh·ªõ h·ªôi tho·∫°i):**
* *M·ª•c ti√™u:* N√¢ng c·∫•p Telegram bot t·ª´ "H·ªèi-ƒê√°p 1 l·∫ßn" sang "Chat qua l·∫°i".
* *Tech:* S·ª≠ d·ª•ng `model.start_chat(history=...)` thay v√¨ `generate_content`.


* [ ] **Long-term Memory (RAG Lite):**
* *M·ª•c ti√™u:* Bot nh·ªõ ƒë∆∞·ª£c c√°c b√†i ch·∫°y qu√° kh·ª© ƒë·ªÉ so s√°nh (V√≠ d·ª•: "H√¥m nay ch·∫°y t·ªët h∆°n tu·∫ßn tr∆∞·ªõc kh√¥ng?").
* *Tech:* L∆∞u t√≥m t·∫Øt JSON v√†o `data/history.json` ho·∫∑c SQLite.


* [ ] **Photo Analysis (Multimodal):**
* *M·ª•c ti√™u:* G·ª≠i ·∫£nh ch·ª•p m√†n h√¨nh bi·ªÉu ƒë·ªì (Stryd/Garmin) ƒë·ªÉ bot ph√¢n t√≠ch.
* *Tech:* T√≠ch h·ª£p model `gemini-2.5-flash` x·ª≠ l√Ω ·∫£nh.



### üìä Phase 3: Advanced Coaching (PLANNING)

* [ ] **Weekly Plan Generator:** T·ª± ƒë·ªông ƒë·ªÅ xu·∫•t l·ªãch ch·∫°y tu·∫ßn sau d·ª±a tr√™n Load tu·∫ßn n√†y.
* [ ] **Injury Prediction:** C·∫£nh b√°o s·ªõm n·∫øu HR/Pace c√≥ d·∫•u hi·ªáu b·∫•t th∆∞·ªùng (Overreaching).

---

## ‚öôÔ∏è Configuration (C·∫•u h√¨nh)

### Environment Variables (.env)

```env
STRAVA_CLIENT_ID=xxxxx
STRAVA_CLIENT_SECRET=xxxxx
VERIFY_TOKEN=xxxxx
GEMINI_API_KEY=xxxxx
TELEGRAM_TOKEN=xxxxx (L∆∞u √Ω: Kh·ªõp t√™n bi·∫øn trong tools/notify_tools.py)

```

### Web Admin URL

* Truy c·∫≠p: `https://tinhn.duckdns.org/admin`
* Ch·ª©c nƒÉng:
* Ch·ªçn Model AI (2.0 Flash / 2.5 Flash).
* S·ª≠a System Instruction (User Profile, Style).
* B·∫≠t/T·∫Øt Debug Mode.



---

*Last Updated: 2026-02-14 | Gap Month Project*
<<< END FILE: ~/repo/AIRuningCoach/README.md

>>> START FILE: ~/repo/AIRuningCoach/.env
# [SECURED] Content hidden. Structure only.
# KEY=******

<<< END FILE: ~/repo/AIRuningCoach/.env

>>> START FILE: ~/repo/AIRuningCoach/requirements.txt
fastapi
uvicorn
requests
python-dotenv
google-generativeai>=0.8.3
pandas
numpy
pydantic
jinja2
python-multipart
<<< END FILE: ~/repo/AIRuningCoach/requirements.txt

>>> START FILE: ~/repo/AIRuningCoach/main.py
import os
import json
import logging
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from collections import deque
from typing import Optional

from fastapi import FastAPI, Request, Form, BackgroundTasks
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, RedirectResponse
from dotenv import load_dotenv

# --- S·ª¨A D√íNG IMPORT QUAN TR·ªåNG N√ÄY ---
# Import ƒë√∫ng h√†m m·ªõi t·ª´ coach_agent v√† tool Strava
from agents.coach_agent import analyze_run_with_gemini, handle_telegram_chat
from tools.strava_client import StravaClient

# --- SETUP ---
load_dotenv()

# Logging for Admin Dashboard
log_capture_string = deque(maxlen=50)
class ListHandler(logging.Handler):
    def emit(self, record):
        log_capture_string.append(self.format(record))

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")
logger = logging.getLogger("AI_COACH")
logger.addHandler(ListHandler())

app = FastAPI()
templates = Jinja2Templates(directory="templates")
CONFIG_PATH = "data/config.json"
SERVICE_ACTIVE = True

# --- HELPER FUNCTIONS ---
def load_config():
    if os.path.exists(CONFIG_PATH):
        try:
            with open(CONFIG_PATH, "r", encoding="utf-8") as f:
                return json.load(f)
        except: return {}
    return {}

def save_config(data):
    with open(CONFIG_PATH, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)
def send_html_email(subject, html_content, config):
    """
    G·ª≠i email b√°o c√°o.
    - Server config: L·∫•y t·ª´ config.json
    - Credentials: L·∫•y t·ª´ bi·∫øn m√¥i tr∆∞·ªùng (.env)
    """
    # 1. L·∫•y Config c√¥ng khai t·ª´ JSON
    email_cfg = config.get("email_config", {})
    if not email_cfg.get("enabled"): 
        return

    # 2. L·∫•y Credentials b√≠ m·∫≠t t·ª´ ENV
    env_sender = os.getenv("EMAIL_SENDER")
    env_password = os.getenv("EMAIL_PASSWORD")
    env_receiver = os.getenv("EMAIL_RECEIVER")
    
    # Ki·ªÉm tra xem c√≥ ƒë·ªß th√¥ng tin ƒëƒÉng nh·∫≠p kh√¥ng
    if not all([env_sender, env_password, env_receiver]):
        logger.error("[EMAIL] Thi·∫øu th√¥ng tin ƒëƒÉng nh·∫≠p trong .env (EMAIL_SENDER/PASSWORD/RECEIVER)")
        return

    try:
        # 3. L·∫•y Server Info t·ª´ JSON (N·∫øu kh√¥ng c√≥ th√¨ d√πng m·∫∑c ƒë·ªãnh Gmail)
        smtp_server = email_cfg.get('smtp_server', 'smtp.gmail.com')
        smtp_port = int(email_cfg.get('smtp_port', 587))

        # 4. C·∫•u h√¨nh Email Message
        msg = MIMEMultipart()
        # [QUAN TR·ªåNG] D√πng bi·∫øn t·ª´ ENV, KH√îNG d√πng email_cfg['sender_email'] n·ªØa
        msg['From'] = env_sender       
        msg['To'] = env_receiver       
        msg['Subject'] = subject
        msg.attach(MIMEText(html_content, 'html'))

        # 5. K·∫øt n·ªëi v√† G·ª≠i
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        # ƒêƒÉng nh·∫≠p b·∫±ng credentials t·ª´ ENV
        server.login(env_sender, env_password)
        server.send_message(msg)
        server.quit()
        
        logger.info(f"[EMAIL] Sent report to {env_receiver}")
        
    except Exception as e:
        logger.error(f"[EMAIL] Failed: {e}")
# --- WORKFLOW: STRAVA PROCESS ---
def run_strava_workflow(activity_id: str):
    if not SERVICE_ACTIVE: return
    
    config = load_config()
    client = StravaClient()
    
    # 1. Fetch Data & Convert to CSV
    logger.info(f"[*] Fetching data for Activity {activity_id}...")
    act_name, csv_data = client.get_activity_data(activity_id)
    
    if not csv_data:
        logger.warning("[!] No valid data found (or not a run).")
        return

    # 2. Analyze with Gemini
    logger.info("[*] Sending CSV data to Gemini...")
    # G·ªçi ƒë√∫ng t√™n h√†m m·ªõi ·ªü ƒë√¢y
    analysis_text = analyze_run_with_gemini(activity_id, act_name, csv_data, config)
    
    if analysis_text:
        # 3. Update Strava Description
        client.update_activity_description(activity_id, analysis_text)
        
        # 4. Send Email Report
        email_body = f"""
        <h2>üèÉ‚Äç‚ôÇÔ∏è Run Analysis: {act_name}</h2>
        <p><a href="https://www.strava.com/activities/{activity_id}">View on Strava</a></p>
        <hr>
        <pre style="white-space: pre-wrap; font-family: sans-serif;">{analysis_text}</pre>
        """
        send_html_email(f"Coach Dyno Report: {act_name}", email_body, config)

# --- ROUTES ---
@app.get("/admin", response_class=HTMLResponse)
async def admin_dashboard(request: Request):
    return templates.TemplateResponse("admin.html", {
        "request": request,
        "config": load_config(),
        "logs": "\n".join(list(log_capture_string)),
        "service_active": SERVICE_ACTIVE
    })

@app.post("/admin/save")
async def save_settings(
    request: Request,
    system_instruction: str = Form(...),
    user_profile: str = Form(...),
    task_description: str = Form(...),
    analysis_requirements: str = Form(...),
    output_format: str = Form(...),
    email_enabled: Optional[str] = Form(None),
    debug_mode: Optional[str] = Form(None),
    model_name: str = Form("models/gemini-2.0-flash")
):
    config = load_config()
    config["system_instruction"] = system_instruction
    config["user_profile"] = user_profile
    config["task_description"] = task_description
    config["analysis_requirements"] = analysis_requirements
    config["output_format"] = output_format
    
    # Email Config
    if "email_config" not in config: config["email_config"] = {}
    config["email_config"]["enabled"] = True if email_enabled == "on" else False
    config["email_config"]["smtp_server"] = "smtp.gmail.com"
    config["email_config"]["smtp_port"] = 587
    # --- 2. TH√äM ƒêO·∫†N N√ÄY ƒê·ªÇ L∆ØU DEBUG MODE ---
    config["debug_mode"] = True if debug_mode == "on" else False
    # ------------------------------------------
    # --- C·∫¨P NH·∫¨T MODEL ---
    config["model_name"] = model_name
    save_config(config)
    logger.info(f"Configuration saved. Active Model: {config['model_name']}")
    # Log ra ƒë·ªÉ ki·ªÉm tra
    logger.info(f"Config Saved. Debug Mode is now: {config['debug_mode']}")
    
    return RedirectResponse(url="/admin", status_code=303)
@app.get("/admin/test-email")
async def test_email_route():
    try:
        cfg = load_config()
        send_html_email("Test Email", "<h1>It Works!</h1>", cfg)
        return {"status": "success"}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.post("/webhook")
async def strava_event(request: Request, background_tasks: BackgroundTasks):
    data = await request.json()
    if data.get("object_type") == "activity" and data.get("aspect_type") == "create":
        activity_id = data.get("object_id")
        logger.info(f"[WEBHOOK] New Activity {activity_id}. Starting workflow.")
        background_tasks.add_task(run_strava_workflow, activity_id)
    return {"status": "ok"}

@app.get("/webhook")
def verify_strava(request: Request):
    if request.query_params.get("hub.verify_token") == os.getenv("VERIFY_TOKEN"):
        return {"hub.challenge": request.query_params.get("hub.challenge")}
    return {"error": "Invalid token"}

@app.post("/telegram-webhook")
async def telegram_event(request: Request, background_tasks: BackgroundTasks):
    data = await request.json()
    if "message" in data:
        chat_id = data["message"]["chat"]["id"]
        text = data["message"].get("text", "")
        logger.info(f"[GATEWAY] Received Telegram: {text}")
        config = load_config()
        background_tasks.add_task(handle_telegram_chat, chat_id, text, config)
    return {"status": "ok"}
<<< END FILE: ~/repo/AIRuningCoach/main.py

>>> START FILE: ~/repo/AIRuningCoach/arch.txt
~/repo/PersonalAI_OS/
‚îÇ
‚îú‚îÄ‚îÄ main.py                 # (Gateway) Tr·∫°m g√°c: H·ª©ng Webhook Strava & Telegram, ƒëi·ªÅu ph·ªëi task
‚îú‚îÄ‚îÄ requirements.txt        # C√°c th∆∞ vi·ªán Python
‚îú‚îÄ‚îÄ .env                    # L∆∞u API Keys (Gemini, Strava, Telegram)
‚îÇ
‚îú‚îÄ‚îÄ agents/                 # N∆°i ch·ª©a "N√£o b·ªô" c·ªßa c√°c Agent
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ coach_agent.py      # K·ªãch b·∫£n suy lu·∫≠n c·ªßa Coach Dyno
‚îÇ   ‚îî‚îÄ‚îÄ news_agent.py       # (ƒê·ªÉ d√†nh cho t∆∞∆°ng lai)
‚îÇ
‚îú‚îÄ‚îÄ tools/                  # N∆°i ch·ª©a "Tay ch√¢n" (C√¥ng c·ª• cho AI g·ªçi)
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ strava_tools.py     # C√°c h√†m t·∫£i CSV, t√≠nh TRIMP, Power
‚îÇ   ‚îî‚îÄ‚îÄ notify_tools.py     # C√°c h√†m g·ª≠i Telegram, Email
‚îÇ
‚îî‚îÄ‚îÄ data/                   # N∆°i ch·ª©a "Tr√≠ nh·ªõ"
    ‚îú‚îÄ‚îÄ memory.sqlite       # (T∆∞∆°ng lai) Database l∆∞u ng·ªØ c·∫£nh chat
    ‚îî‚îÄ‚îÄ config.json         # L∆∞u System Prompt, User Profile
<<< END FILE: ~/repo/AIRuningCoach/arch.txt

>>> START FILE: ~/repo/AIRuningCoach/templates/admin.html
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèÉ‚Äç‚ôÇÔ∏è AI Coach Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background-color: #f8f9fa; }
        .log-box { background: #1e1e1e; color: #00ff00; height: 300px; overflow-y: scroll; font-family: monospace; padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <nav class="navbar navbar-dark bg-primary mb-4">
        <div class="container">
            <a class="navbar-brand" href="#">üèÉ‚Äç‚ôÇÔ∏è AI Running Coach Admin</a>
            <span class="badge bg-warning text-dark">Status: {{ "RUNNING" if service_active else "PAUSED" }}</span>
        </div>
    </nav>

    <div class="container">
        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-dark text-white">‚öôÔ∏è System Control</div>
                    <div class="card-body">
                        <form action="/admin/toggle" method="post" class="d-inline">
                            {% if service_active %}
                            <button type="submit" class="btn btn-danger w-100">‚è∏ PAUSE SERVICE (Stop Processing)</button>
                            {% else %}
                            <button type="submit" class="btn btn-success w-100">‚ñ∂Ô∏è RESUME SERVICE</button>
                            {% endif %}
                        </form>
                        <hr>
                        <button type="button" onclick="testEmail()" class="btn btn-outline-primary w-100">üìß Test Email Notification</button>
                        <script>
                        async function testEmail() {
                            const logBox = document.getElementById("logBox");
                            logBox.innerHTML += "\n[SYSTEM] Sending test email...";

                            try {
                                const response = await fetch('/admin/test-email');
                                const result = await response.json();

                                if (result.status === 'success') {
                                    logBox.innerHTML += "\n[SUCCESS] Email sent! Check your inbox.";
                                } else {
                                    logBox.innerHTML += "\n[ERROR] Failed: " + result.message;
                                }
                            } catch (err) {
                                logBox.innerHTML += "\n[ERROR] Network error: " + err;
                            }
                            logBox.scrollTop = logBox.scrollHeight;
                        }
                        </script>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                 <div class="card">
                    <div class="card-header bg-dark text-white">üìú Live Logs (Last 50 lines)</div>
                    <div class="card-body p-0">
                        <div class="log-box" id="logBox">{{ logs }}</div>
                    </div>
                 </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header bg-primary text-white">üìù Configuration Editor</div>
            <div class="card-body">
                <form action="/admin/save" method="post">
                    <div class="mb-3">
                        <label class="form-label fw-bold">System Instruction (AI Role)</label>
                        <textarea class="form-control" name="system_instruction" rows="2">{{ config.system_instruction }}</textarea>
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold">User Profile</label>
                        <textarea class="form-control" name="user_profile" rows="4">{{ config.user_profile }}</textarea>
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold">Task Description</label>
                        <textarea class="form-control" name="task_description" rows="2">{{ config.task_description }}</textarea>
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold">Analysis Requirements</label>
                        <textarea class="form-control" name="analysis_requirements" rows="4">{{ config.analysis_requirements }}</textarea>
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold">Output Format</label>
                        <textarea class="form-control" name="output_format" rows="4">{{ config.output_format }}</textarea>
                    </div>
                    
                    <h5 class="mt-4 text-primary">üìß Email Settings</h5>
                    <div class="row">
                         <div class="col-md-12 mb-3 form-check ms-3">
                            <input class="form-check-input" type="checkbox" name="email_enabled" id="emailEnabled" {% if config.email_config.enabled %}checked{% endif %}>
                            <label class="form-check-label" for="emailEnabled">Enable Email Notification</label>
                        </div>
                    </div>
                    <div class="row mb-3">
                        <div class="col-md-12">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" name="debug_mode" id="debugMode" {% if config.debug_mode %}checked{% endif %}>
                                <label class="form-check-label fw-bold text-danger" for="debugMode">üêû Enable Deep Debug Logging (Show Prompts & Raw Data)</label>
                            </div>
                        </div>
                    </div>
                    <div class="mb-4 p-3 border rounded bg-light">
                        <label class="form-label fw-bold text-primary">üß† AI Brain Model (Live Switch)</label>
                        <select class="form-select" name="model_name">
                            <option value="models/gemini-flash-latest" {% if config.get('model_name') == 'models/gemini-flash-latest' %}selected{% endif %}>
                                Gemini Flash Latest (Lu√¥n l√† b·∫£n m·ªõi nh·∫•t - Quota th·∫•p)
                            </option>
                            <option value="models/gemini-2.5-flash" {% if config.get('model_name') == 'models/gemini-2.5-flash' %}selected{% endif %}>
                                Gemini 2.5 Flash (Smarter - T·ªët cho ph√¢n t√≠ch chuy√™n s√¢u)
                            </option>
                            <option value="models/gemini-2.0-flash" {% if config.get('model_name') == 'models/gemini-2.0-flash' %}selected{% endif %}>
                                Gemini 2.0 Flash (Recommended - ·ªîn ƒë·ªãnh & Nhanh)
                            </option>
                            
                            <option value="models/gemini-1.5-flash" {% if config.get('model_name') == 'models/gemini-1.5-flash' %}selected{% endif %}>
                                Gemini 1.5 Flash (R·∫•t ·ªïn ƒë·ªãnh - Quota cao)
                            </option>
                    
                            <option value="models/gemini-2.0-flash-lite-preview-02-05" {% if config.get('model_name') == 'models/gemini-2.0-flash-lite-preview-02-05' %}selected{% endif %}>
                                Gemini 2.0 Flash Lite (B·∫£n nh·∫π - Si√™u t·ªëc)
                            </option>
                            
                            <option value="models/gemini-2.0-pro-exp-02-05" {% if config.get('model_name') == 'models/gemini-2.0-pro-exp-02-05' %}selected{% endif %}>
                                Gemini 2.0 Pro Experimental (R·∫•t th√¥ng minh - Hay b·ªã gi·ªõi h·∫°n)
                            </option>
                        </select>
                        <div class="form-text text-muted">Thay ƒë·ªïi c√≥ hi·ªáu l·ª±c ngay l·∫≠p t·ª©c cho tin nh·∫Øn ti·∫øp theo.</div>
                    </div>
                    <button type="submit" class="btn btn-primary btn-lg w-100 mt-3">üíæ SAVE CONFIGURATION</button>
                </form>
            </div>
        </div>
    </div>
    
    <script>
        // Auto scroll to bottom of logs
        var logBox = document.getElementById("logBox");
        logBox.scrollTop = logBox.scrollHeight;
    </script>
</body>
</html>
<<< END FILE: ~/repo/AIRuningCoach/templates/admin.html

>>> START FILE: ~/repo/AIRuningCoach/docs/setup.md

<<< END FILE: ~/repo/AIRuningCoach/docs/setup.md

>>> START FILE: ~/repo/AIRuningCoach/docs/architecture.md
graph TD
    User((User)) <-->|Chat/Query| Interface[Telegram/Web UI]
    Strava[Strava Webhook] -->|Data| AgentCore
    Weather[Weather API] -->|Context| AgentCore
    
    subgraph "The AI AGENT (Brain)"
        AgentCore{Orchestrator (Gemini)}
        
        subgraph "Memory (RAG)"
            ShortTerm[Log b√†i t·∫≠p tu·∫ßn n√†y]
            LongTerm[L·ªãch s·ª≠ ch·∫•n th∆∞∆°ng, PR c≈©]
            Knowledge[S√°ch/Gi√°o √°n ch·∫°y b·ªô]
        end
        
        subgraph "Tools (Tay ch√¢n)"
            Tool_Analysis[Ph√¢n t√≠ch CSV (Code hi·ªán t·∫°i)]
            Tool_Plan[L·∫≠p l·ªãch t·∫≠p (Google Calendar)]
            Tool_Weather[Check th·ªùi ti·∫øt]
            Tool_Search[Search Google (Ki·∫øn th·ª©c m·ªõi)]
        end
    end

    AgentCore <--> Memory
    AgentCore --> Tools
    
    Tools -->|Update| StravaOutput[Strava Activity]
    Tools -->|Notify| Email_Telegram[Alert]
<<< END FILE: ~/repo/AIRuningCoach/docs/architecture.md

>>> START FILE: ~/repo/AIRuningCoach/docs/changelog.md

<<< END FILE: ~/repo/AIRuningCoach/docs/changelog.md

>>> START FILE: ~/repo/AIRuningCoach/docs/flows.md

<<< END FILE: ~/repo/AIRuningCoach/docs/flows.md

>>> START FILE: ~/repo/AIRuningCoach/tools/__init__.py

<<< END FILE: ~/repo/AIRuningCoach/tools/__init__.py

>>> START FILE: ~/repo/AIRuningCoach/tools/strava_client.py
import os
import logging
import requests
import pandas as pd
from dotenv import load_dotenv

# Initialize logging
logger = logging.getLogger(__name__)
load_dotenv()

class StravaClient:
    def __init__(self):
        self.client_id = os.getenv("STRAVA_CLIENT_ID")
        self.client_secret = os.getenv("STRAVA_CLIENT_SECRET")
        self.refresh_token = os.getenv("STRAVA_REFRESH_TOKEN")
        self.auth_url = "https://www.strava.com/oauth/token"
        self.base_url = "https://www.strava.com/api/v3"

    def get_access_token(self):
        """Refresh and retrieve a valid access token."""
        payload = {
            'client_id': self.client_id,
            'client_secret': self.client_secret,
            'refresh_token': self.refresh_token,
            'grant_type': 'refresh_token'
        }
        try:
            response = requests.post(self.auth_url, data=payload)
            response.raise_for_status()
            return response.json().get('access_token')
        except Exception as e:
            logger.error(f"[STRAVA] Failed to refresh token: {e}")
            return None

    def get_activity_data(self, activity_id: str):
        """
        Fetch activity streams (HR, Cadence, Velocity) and convert to CSV string.
        Returns: (activity_name, csv_data_string)
        """
        token = self.get_access_token()
        if not token:
            return None, None

        headers = {'Authorization': f'Bearer {token}'}
        
        # 1. Get Activity Details (Name, Type)
        try:
            act_url = f"{self.base_url}/activities/{activity_id}"
            act_res = requests.get(act_url, headers=headers)
            if act_res.status_code != 200:
                logger.error(f"[STRAVA] Error fetching activity: {act_res.text}")
                return None, None
            
            act_data = act_res.json()
            activity_name = act_data.get('name', 'Unknown Run')
            
            # Check type (Run, VirtualRun, etc.)
            if act_data.get('type') not in ['Run', 'VirtualRun', 'TrailRun', 'Treadmill']:
                logger.info(f"[STRAVA] Activity {activity_id} is not a run. Skipping.")
                return None, None

            # 2. Get Streams
            streams_url = f"{act_url}/streams?keys=time,heartrate,velocity_smooth,cadence,grade_smooth&key_by_type=true"
            streams_res = requests.get(streams_url, headers=headers).json()

            # 3. Process with Pandas (Logic ported from old script)
            data = {
                'Time_sec': streams_res.get('time', {}).get('data', []),
                'HR_bpm': streams_res.get('heartrate', {}).get('data', []),
                'Velocity_m_s': streams_res.get('velocity_smooth', {}).get('data', []),
                'Cadence_spm': streams_res.get('cadence', {}).get('data', []),
                'Grade_pct': streams_res.get('grade_smooth', {}).get('data', [])
            }
            
            # Create DataFrame
            df = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in data.items()]))
            
            # Clean data (Drop rows with missing critical data)
            df.dropna(subset=['HR_bpm', 'Velocity_m_s'], inplace=True)
            
            # Convert to CSV string for Gemini
            csv_data = df.to_csv(index=False)
            logger.info(f"[STRAVA] Successfully processed CSV data for {activity_id}")
            
            return activity_name, csv_data

        except Exception as e:
            logger.error(f"[STRAVA] Error processing activity data: {e}")
            return None, None

    def update_activity_description(self, activity_id: str, description: str):
        """Update the description of a Strava activity."""
        token = self.get_access_token()
        if not token: return False

        url = f"{self.base_url}/activities/{activity_id}"
        headers = {'Authorization': f'Bearer {token}'}
        payload = {'description': description}

        try:
            response = requests.put(url, headers=headers, json=payload)
            if response.status_code == 200:
                logger.info(f"[STRAVA] Description updated for {activity_id}")
                return True
            else:
                logger.error(f"[STRAVA] Failed update: {response.text}")
                return False
        except Exception as e:
            logger.error(f"[STRAVA] Error updating description: {e}")
            return False
<<< END FILE: ~/repo/AIRuningCoach/tools/strava_client.py

>>> START FILE: ~/repo/AIRuningCoach/tools/strava_tools.py
import numpy as np
import logging

logger = logging.getLogger(__name__)

def calculate_trimp(duration_minutes: float, avg_hr: float, max_hr: int = 185, rest_hr: int = 55) -> dict:
    """
    Calculate Training Impulse (TRIMP) using Bannister's method.
    Returns a dictionary containing TRIMP score and evaluated intensity.
    """
    try:
        # Calculate Heart Rate Reserve (HRR)
        hrr = (avg_hr - rest_hr) / (max_hr - rest_hr)
        hrr = max(0, hrr) # Ensure HRR is not negative
        
        # Bannister's formula for males
        weight = 0.64 * np.exp(1.92 * hrr)
        trimp = duration_minutes * hrr * weight
        trimp_rounded = round(trimp, 2)
        
        # Evaluate intensity zone based on TRIMP score
        intensity = "Easy/Recovery"
        if trimp_rounded > 120:
            intensity = "High (Overreaching if scheduled for recovery)"
        elif trimp_rounded > 70:
            intensity = "Medium (Tempo/Threshold)"
            
        logger.info(f"[Strava Tool] TRIMP calculated: {trimp_rounded} - {intensity}")
        
        return {
            "trimp": trimp_rounded,
            "intensity_level": intensity,
            "avg_hr": avg_hr,
            "duration": duration_minutes
        }
    except Exception as e:
        logger.error(f"[Strava Tool] Calculation error: {e}")
        return {"error": str(e)}
<<< END FILE: ~/repo/AIRuningCoach/tools/strava_tools.py

>>> START FILE: ~/repo/AIRuningCoach/tools/notify_tools.py
import os
import logging
import requests
from dotenv import load_dotenv

load_dotenv()
logger = logging.getLogger(__name__)

def send_telegram_msg(chat_id, text):
    token = os.getenv("TELEGRAM_BOT_TOKEN")
    if not token:
        logger.error("[TELEGRAM] No token found in environment variables.")
        return

    url = f"https://api.telegram.org/bot{token}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": text,
        "parse_mode": "Markdown" # ƒê·ªÉ bot in ƒë·∫≠m/nghi√™ng ƒë·∫πp h∆°n
    }
    
    try:
        response = requests.post(url, json=payload)
        if response.status_code != 200:
            logger.error(f"[TELEGRAM] Failed to send message: {response.text}")
    except Exception as e:
        logger.error(f"[TELEGRAM] Connection error: {e}")
<<< END FILE: ~/repo/AIRuningCoach/tools/notify_tools.py

>>> START FILE: ~/repo/AIRuningCoach/agents/__init__.py

<<< END FILE: ~/repo/AIRuningCoach/agents/__init__.py

>>> START FILE: ~/repo/AIRuningCoach/agents/coach_agent.py
import os
import logging
import google.generativeai as genai
from tools.notify_tools import send_telegram_msg
# Configure logging
logger = logging.getLogger(__name__)
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

def analyze_run_with_gemini(activity_id: str, activity_name: str, csv_data: str, config: dict):
    """
    Sends Raw Run Data (CSV) to Gemini for detailed analysis.
    """
    logger.info(f"[COACH AGENT] Analyzing run: {activity_name} (ID: {activity_id})")

    system_instruction = config.get("system_instruction", "You are Coach Dyno.")
    user_profile = config.get("user_profile", "")
    analysis_requirements = config.get("analysis_requirements", "Analyze HR and Power.")
    output_format = config.get("output_format", "Output in Vietnamese.")
    
    # --- DEBUG: CHECK MODE ---
    debug_mode = config.get("debug_mode", False)
    
    # 1. L·∫§Y T√äN MODEL T·ª™ CONFIG (Live Affect)
    # M·∫∑c ƒë·ªãnh v·ªÅ 2.0 Flash n·∫øu config ch∆∞a c√≥
    current_model_name = config.get("model_name", "models/gemini-2.0-flash")
    
    if config.get("debug_mode"):
        logger.info(f"[SYSTEM] Initializing AI Brain: {current_model_name}")
    
    # 2. KH·ªûI T·∫†O CLIENT
    try:
        model = genai.GenerativeModel(
            model_name=current_model_name,
            system_instruction=system_instruction
        )
        # ... ti·∫øp t·ª•c logic generate ...
    except Exception as e:
        logger.error(f"Error initializing model {current_model_name}: {e}")
        return None

    # Construct Prompt
    prompt = f"""
    [TASK CONTEXT]
    Activity Name: {activity_name}
    User Profile: {user_profile}
    
    [ANALYSIS REQUIREMENTS]
    {analysis_requirements}
    
    [OUTPUT FORMAT INSTRUCTION]
    {output_format}
    
    [RAW DATA - CSV FORMAT]
    (Time, HR, Velocity, Cadence, Grade)
    {csv_data}
    """
    
# --- DEBUG: LOG PROMPT (CLEAN VERSION) ---
    if debug_mode:
        logger.info("="*30 + " [DEBUG] PROMPT TO GEMINI " + "="*30)
        
        # T·∫°o b·∫£n sao c·ªßa prompt ƒë·ªÉ log, thay th·∫ø data th·∫≠t b·∫±ng placeholder
        # C√°ch n√†y gi√∫p anh v·∫´n nh√¨n th·∫•y System Instruction & User Profile
        log_prompt = prompt.replace(csv_data, f"\n[...RAW CSV DATA HIDDEN ({len(csv_data)} bytes)...]\n")
        
        logger.info(log_prompt)
        logger.info("="*80)
    try:
        response = model.generate_content(prompt)
        analysis_text = response.text
        
        # --- DEBUG: LOG FULL RESPONSE ---
        if debug_mode:
            logger.info("="*30 + " [DEBUG] GEMINI RAW RESPONSE " + "="*30)
            logger.info(analysis_text)
            logger.info("="*80)
            
        logger.info("[COACH AGENT] Analysis generated successfully.")
        return analysis_text
    except Exception as e:
        logger.error(f"[COACH AGENT] Gemini Error: {e}")
        return None

def handle_telegram_chat(chat_id: str, text: str, config: dict):
    """
    Workflow triggered when the user sends a message via Telegram.
    """
    # 1. Check Debug Mode & Log
    debug_mode = config.get("debug_mode", False)
    if debug_mode:
        logger.info(f"[TELEGRAM] Processing message from {chat_id}: {text}")

    # 2. L·∫•y t√™n Model t·ª´ Config (Live Switch)
    current_model_name = config.get("model_name", "models/gemini-2.0-flash")
    
    # 3. L·∫•y System Instruction
    system_instruction = config.get("system_instruction", "You are Coach Dyno.")
    user_profile = config.get("user_profile", "")

    # 4. Kh·ªüi t·∫°o Model (Local Scope)
    try:
        model = genai.GenerativeModel(
            model_name=current_model_name,
            system_instruction=system_instruction
        )
    except Exception as e:
        logger.error(f"[TELEGRAM] Error initializing model {current_model_name}: {e}")
        send_telegram_msg(chat_id, "‚ö†Ô∏è System Error: Invalid AI Model configuration.")
        return

    # 5. T·∫°o Prompt
    prompt = f"""
    [USER CONTEXT]
    {user_profile}

    [USER MESSAGE]
    {text}
    
    [INSTRUCTION]
    Reply directly to the user. Be concise, strict but helpful.
    """
    
    if debug_mode:
        logger.info("="*30 + " [TELEGRAM DEBUG PROMPT] " + "="*30)
        logger.info(prompt)

    try:
        # 6. G·ªçi Gemini
        response = model.generate_content(prompt)
        reply_text = response.text
        
        if debug_mode:
            logger.info(f"[TELEGRAM DEBUG RESPONSE]: {reply_text}")

        # 7. G·ª≠i ph·∫£n h·ªìi v·ªÅ Telegram
        send_telegram_msg(chat_id, reply_text)
        
    except Exception as e:
        # --- ƒê√ÇY L√Ä ƒêO·∫†N B·ªä L·ªñI TR∆Ø·ªöC ƒê√ì, H√ÉY CH√âP K·ª∏ ---
        logger.error(f"[TELEGRAM] Error during chat handling: {e}")
        send_telegram_msg(chat_id, "‚ö†Ô∏è Coach Dyno ƒëang b·ªã 'chu·ªôt r√∫t' (L·ªói API). Th·ª≠ l·∫°i sau nh√©!")
<<< END FILE: ~/repo/AIRuningCoach/agents/coach_agent.py

==================== SCANNING: /home/tinhn/nginx-proxy ====================
--- STRUCTURE: nginx-proxy ---
nginx-proxy/
    docker-compose.yml
    duckdns-config/
        logrotate.conf

--- CONTENTS: nginx-proxy ---

>>> START FILE: ~/nginx-proxy/docker-compose.yml
version: '3.8'
services:
  app:
    image: 'jc21/nginx-proxy-manager:latest'
    container_name: nginx_proxy_manager
    restart: unless-stopped
    ports:
      - '80:80'      # C·ªïng Web (HTTP) - B·∫Øt bu·ªôc
      - '81:81'      # C·ªïng Qu·∫£n l√Ω (Admin UI)
      - '443:443'    # C·ªïng SSL (HTTPS) - B·∫Øt bu·ªôc
    volumes:
      - ./data:/data
      - ./letsencrypt:/etc/letsencrypt
# === TH√äM ƒêO·∫†N N√ÄY ===
  ai-coach:
    build: ../repo/AIRuningCoach  # ƒê∆∞·ªùng d·∫´n sang th∆∞ m·ª•c code c·ªßa anh
    container_name: airunningcoach
    restart: unless-stopped
    ports:
      - '8000:8000'
    env_file:
      - ../repo/AIRuningCoach/.env # L·∫•y file m·∫≠t kh·∫©u t·ª´ b√™n kia sang
    volumes:
      - ../repo/AIRuningCoach:/app # Mount code ƒë·ªÉ s·ª≠a live ƒë∆∞·ª£c
# 3. DUCKDNS (T·ª± ƒë·ªông c·∫≠p nh·∫≠t IP) - M·ªöI TH√äM
  duckdns:
    image: lscr.io/linuxserver/duckdns:latest
    container_name: duckdns
    network_mode: host # Quan tr·ªçng: ƒê·ªÉ l·∫•y ƒë√∫ng IP Public c·ªßa m·∫°ng nh√†
    environment:
      - PUID=1000       # User ID m·∫∑c ƒë·ªãnh
      - PGID=100        # Group ID m·∫∑c ƒë·ªãnh
      - TZ=Asia/Ho_Chi_Minh
      - SUBDOMAINS=tinhn    # <--- S·ª¨A T√äN N√ÄY (ch·ªâ ƒëi·ªÅn ph·∫ßn ƒë·∫ßu, ko ƒëi·ªÅn .duckdns.org)
      - TOKEN=072c2a8e-56d1-41d3-af61-9524f9ae4313  # <--- D√ÅN TOKEN L·∫§Y T·ª™ WEB DUCKDNS
      - LOG_FILE=false
    volumes:
      - ./duckdns-config:/config # N∆°i l∆∞u file c·∫•u h√¨nh DuckDNS
    restart: unless-stopped

<<< END FILE: ~/nginx-proxy/docker-compose.yml

>>> START FILE: ~/nginx-proxy/duckdns-config/logrotate.conf
/config/duck.log {
    rotate 5
    size 100k
    compress
}

<<< END FILE: ~/nginx-proxy/duckdns-config/logrotate.conf
