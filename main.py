import os
import requests
import pandas as pd
import google.generativeai as genai
from fastapi import FastAPI, Request, BackgroundTasks
from dotenv import load_dotenv

# Load environment variables
load_dotenv()
app = FastAPI()

# USER PROFILE CONFIGURATION
USER_PROFILE = """
- Role: Serious amateur runner.
- Goal: Half Marathon Sub 2 hours.
- Max Heart Rate (HR Max): 185 bpm.
- Resting Heart Rate: 49 bpm.
- History: Completed 8 Full Marathons. PB HM: 2h08.
- Gear: Garmin 955, Sony WF-1000XM5.
- Coaching Style: Professional, strict but encouraging, data-driven, focus on physiology.
"""

# Setup Gemini AI
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
model = genai.GenerativeModel('gemini-1.5-flash')

def get_access_token():
    """Fetches a fresh Access Token using the Refresh Token."""
    url = "https://www.strava.com/oauth/token"
    payload = {
        'client_id': os.getenv("STRAVA_CLIENT_ID"),
        'client_secret': os.getenv("STRAVA_CLIENT_SECRET"),
        'refresh_token': os.getenv("STRAVA_REFRESH_TOKEN"),
        'grant_type': 'refresh_token'
    }
    try:
        res = requests.post(url, data=payload)
        res.raise_for_status()
        return res.json().get('access_token')
    except Exception as e:
        print(f"[!] Error refreshing Strava token: {e}")
        return None

def process_activity(activity_id):
    """Background task to fetch data, analyze, and update Strava."""
    print(f"[*] Processing Activity ID: {activity_id}")
    
    access_token = get_access_token()
    if not access_token:
        return

    headers = {'Authorization': f'Bearer {access_token}'}

    # 1. Fetch General Activity Data
    try:
        act_url = f"https://www.strava.com/api/v3/activities/{activity_id}"
        act_data = requests.get(act_url, headers=headers).json()
        
        # Filter: Only process 'Run' activities
        allowed_types = ['Run', 'VirtualRun', 'TrailRun', 'Treadmill']
        if act_data.get('type') not in allowed_types:
            print(f"[-] Activity type is '{act_data.get('type')}'. Skipping.")
            return

        # 2. Fetch RAW STREAMS
        streams_url = f"{act_url}/streams?keys=time,heartrate,velocity_smooth,cadence,grade_smooth&key_by_type=true"
        streams_res = requests.get(streams_url, headers=headers).json()

        # 3. Transform Data to CSV String
        data = {
            'Time_sec': streams_res.get('time', {}).get('data', []),
            'HR_bpm': streams_res.get('heartrate', {}).get('data', []),
            'Velocity_m_s': streams_res.get('velocity_smooth', {}).get('data', []),
            'Cadence_spm': streams_res.get('cadence', {}).get('data', []),
            'Grade_pct': streams_res.get('grade_smooth', {}).get('data', [])
        }
        
        df = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in data.items()]))
        # Clean data: remove rows without HR or Velocity
        df.dropna(subset=['HR_bpm', 'Velocity_m_s'], inplace=True)
        csv_data = df.to_csv(index=False)
        print(f"[+] Data fetched. Stream length: {len(df)} rows.")

    except Exception as e:
        print(f"[!] Error fetching/processing Strava data: {e}")
        return

    # 4. Construct Prompt and Call Gemini
    prompt = f"""
    [System Instruction]
    You are a professional running coach specializing in data analysis and physiology.
    
    [User Profile]
    {USER_PROFILE}
    
    [Task]
    Analyze the following running workout based on the raw second-by-second data.
    
    [Analysis Requirements]
    1. **Effort Analysis:** Based on HR Max (185) and Resting (49), determine the primary Heart Rate Zones used.
    2. **Pacing Strategy:** Analyze 'Velocity_m_s'. Did the runner maintain a steady pace? Look for positive/negative splits.
    3. **Technique & Terrain:** Correlation between 'Cadence_spm' and 'Grade_pct'.
    4. **Verdict:** Give a short, actionable summary for the next session.
    
    [Format]
    - Use Markdown formatting.
    - **Language: Vietnamese**.
    - Tone: Professional, constructive, "tough love".
    
    [Raw Data CSV]
    {csv_data}
    """
    
    try:
        print("[*] Sending data to Gemini...")
        response = model.generate_content(prompt)
        analysis_text = response.text + "\n\n---\n*Analysis generated by AI Coach (Gemini 2.0)*"
        print("[+] Analysis received from Gemini.")
        
    except Exception as e:
        print(f"[!] Gemini API Error: {e}")
        return

    # 5. Update Strava Activity Description
    try:
        update_data = {'description': analysis_text}
        update_res = requests.put(act_url, headers=headers, json=update_data)
        
        if update_res.status_code == 200:
            print(f"[SUCCESS] Strava Activity {activity_id} updated successfully.")
        else:
            print(f"[!] Failed to update Strava. Status: {update_res.status_code}")
            
    except Exception as e:
        print(f"[!] Error updating Strava: {e}")

@app.get("/webhook")
def verify_webhook(request: Request):
    challenge = request.query_params.get("hub.challenge")
    verify_token = request.query_params.get("hub.verify_token")
    if verify_token == os.getenv("VERIFY_TOKEN"):
        return {"hub.challenge": challenge}
    return {"error": "Invalid verification token"}

@app.post("/webhook")
async def webhook_handler(request: Request, background_tasks: BackgroundTasks):
    try:
        data = await request.json()
        if data.get("object_type") == "activity" and data.get("aspect_type") == "create":
            background_tasks.add_task(process_activity, data.get("object_id"))
            print(f"[Webhook] Received new activity.")
        return {"status": "ok"}
    except Exception as e:
        print(f"[!] Webhook error: {e}")
        return {"status": "error"}